#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <stdbool.h> 
int solutions_counter = 0; // global counter variable to count how many solutions are generated

/*
This version correctly displays the first possible solution for the generated board
*/

typedef struct{
    _Bool candidates[9];
    int value;
} board_box;

// Function List
void swap (int *a, int *b);
board_box** allocateArray(int rows, int cols);
void deallocateArray(int** arr,int rows);
void fillPuzzle (int arr[], int n, board_box **displayPuzzle, int iMin, int jMin);
void printBoard (board_box **displayPuzzle);
board_box** copyPuzzle (board_box **displayPuzzle);
void randomizeRowDuplicate(board_box **displayPuzzle);
void randomizeColDuplicate(board_box **displayPuzzle);
void getRowCandidates (board_box **displayPuzzle);
void getColCandidates (board_box **displayPuzzle);
void getBoxCandidates (board_box **displayPuzzle);
void getCandidates (board_box **displayPuzzle);
void fillCandidates (board_box **displayPuzzle);
void randomize ( int arr[], int n );
board_box** setupPuzzle(int arr[], int n);
_Bool isValidBoard(board_box **displayPuzzle);
void killRandomly(board_box **displayPuzzle);
board_box **create_fake_puzzle();
_Bool recursive_prune(board_box **displayPuzzle);

// Main
int main()
{
    int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9}; //array full of values in Sudoku puzzle 
    int n = sizeof(arr)/ sizeof(arr[0]); //Comes out to 9
    int main_iterations = 0; //This variable will keep track of how many iterations of main until we find puzzle
    while(1){
        board_box **displayPuzzle = setupPuzzle(arr,n); //We use the setup functions to get 9x9 array of random values
        //board_box **fakepuzzle = create_fake_puzzle();
        //fillCandidates(displayPuzzle);
        randomizeRowDuplicate(displayPuzzle); //These randomize functions remove the dupplicates from rows and colomns randomly
        randomizeColDuplicate(displayPuzzle);
        do{ //We stay in this loop until the board we have has a candidate for every blank spot
            killRandomly(displayPuzzle); //By killing randomly we increase number of possible candidates
            fillCandidates(displayPuzzle); //We needs to recalibrate the candidates after each kill
            getCandidates(displayPuzzle);
        }while(isValidBoard(displayPuzzle) != 1);//Once the board is valid under these conditions we move on
        board_box **origional_puzzle = copyPuzzle(displayPuzzle); // This saves the possible puzzle board in new board box variable 
        main_iterations ++; //Increment main iterations
        //solutions_counter = 0;
        //recursive_prune(displayPuzzle); // could make it where break within prune if solutions > 1
        if(recursive_prune(displayPuzzle)) //If recursive prune ever returns true then we know we found solution
        {
            int answer;
            printf("Randomly Generated Puzzle Board\n");
            printBoard(origional_puzzle); //Display puzzle board pre solution
            printf("\nWould you like to see the solution?: Yes = 1 No =0\n");
            scanf("%d",&answer); //Ask user if they would like to see the solution
            if(answer)
            {
                printf("\nSolution for Randomly Generated Puzzle Board \n");
                printBoard(displayPuzzle);
            } //Display solution generated by recurisve prune
            printf("It took %d iterations of the main loop to generate this puzzle\n",main_iterations); //display how many iterations it took
            break;
        }
        free(displayPuzzle); //free the allocated memory for the puzzles
        free(origional_puzzle);
    }
    return 0;
}

//Auxillory Functions
void swap (int *a, int *b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}

void randomize ( int arr[], int n )
{
    srand ( time(NULL) );
 
    for (int i = n-1; i > 0; i--)
    {
        int j = rand() % (i+1);
        swap(&arr[i], &arr[j]);
    }
}
board_box** allocateArray(int rows, int cols){ //This function allocates memory for an array of rows x cols
    board_box **arr;
    int i;
    arr = (board_box**)malloc(rows*sizeof(board_box*));
    for(i=0;i<rows;i++)
        arr[i] = (board_box*)malloc(cols*sizeof(board_box));
    return arr;
}

void fillPuzzle (int arr[], int n, board_box **displayPuzzle, int iMin, int jMin)
{
    int i,j,count;
    if((iMin == 0) & (jMin == 0))
        memset(*displayPuzzle,0,sizeof displayPuzzle); //fills display puzzle with 0's
    int iMax, jMax;
    iMax = iMin + 2; //gets end positions of box coordinate i and j 
    jMax = jMin + 2;
    count = 0;
    for (i=iMin;i<=iMax;i++)
    {
        for(j=jMin;j<=jMax;j++)
        {
            displayPuzzle[i][j].value = arr[count]; //fills the box with values from randomized array
            count++;
        }
    }
}
board_box** copyPuzzle (board_box **displayPuzzle){
    board_box **newPuzzle = allocateArray(9,9);
    for (int i=0;i<=8;i++)
    {
        for(int j=0;j<=8;j++)
        {
            newPuzzle[i][j].value = displayPuzzle[i][j].value;
        }
    }
    return newPuzzle;
}

void printBoard (board_box **displayPuzzle)
{
    for (int i=0;i<=8;i++) //This function displays the puzzle
    {
        for(int j=0;j<=8;j++)
        {
            if((i == 0 || i == 3 || i == 6) && j ==0)
            {
                printf("------------------------------------------------------------------\n");
            }
            if(j==0)
                printf("|%d\t",displayPuzzle[i][j].value);
            else if(j==2 || j==5 || j==8)
                printf("%d|\t",displayPuzzle[i][j].value);
            else
                printf("%d\t",displayPuzzle[i][j].value);
        }
       printf("\n");
    }   
    printf("------------------------------------------------------------------\n");
}

board_box** setupPuzzle(int arr[], int n)
{
    int iMin,jMin;
    board_box **displayPuzzle = allocateArray(9,9);
    for(int i = 0; i <= 8; i++) //We loop 9 times, once for each box
    {
        switch(i){
        case 0 :
            iMin = 0;
            jMin = 0;
            break;
        case 1 :
            iMin = 0;
            jMin = 3;
            break;
        case 2 :
            iMin = 0;
            jMin = 6;
            break;
        case 3 :
            iMin = 3;
            jMin = 0;
            break;
        case 4 :
            iMin = 3;
            jMin = 3;
            break;
        case 5 :
            iMin = 3;
            jMin = 6;
            break;
        case 6:
            iMin = 6;
            jMin = 0;
            break;
        case 7 :    
            iMin = 6;
            jMin = 3;
            break;
        case 8 :
            iMin = 6;
            jMin = 6;
            break;
        } // This gets the i and j start positions for each box
        randomize (arr, n); //We then randomize the order of the array from 1-9
        fillPuzzle(arr, n, displayPuzzle, iMin, jMin ); //Input this randomzied array and box positons to function to set values
    } 
    return displayPuzzle; //return the set up puzzle board with all filled boxes
}
void fillCandidates (board_box **displayPuzzle){
    //printf("\nFilling Candidates:\n\n");
    for(int i = 0;i<=8;i++){
        for(int j = 0;j<=8;j++)
        {
            for (int p=1;p<=9;p++) //Go through every element in the row
            {
                displayPuzzle[i][j].candidates[p-1] = p; //sets every candidate to true for the spot
            }            
        }
    }
} 
void randomizeRowDuplicate(board_box **displayPuzzle){ 
    int countInstance = 0;
    for(int a = 1;a<=9;a++){
        for(int i = 0; i<=8; i++)
        {
            for(int j = 0; j<=8; j++){
                if(displayPuzzle[i][j].value == a) //If the value a is in the spot, we increase a variable
                    countInstance++; //This will count the amount of instances of a in row 0 
            }
            while(countInstance > 1){ //We loop until there is only one instance of any value
                int randomNumber = (rand() % 9)+1; 
                if(displayPuzzle[i][randomNumber].value == a){ //We randomly kill a spot in row that has the duplicate value
                    //kill
                    displayPuzzle[i][randomNumber].value = 0;
                    //decrement
                    countInstance --;
                }
            }
            countInstance = 0; //reset counter to 0 after each iteration
        }
    } 
} 
void randomizeColDuplicate(board_box **displayPuzzle){ 
    int countInstance = 0;
    for(int a = 1;a<=9;a++){
        for(int j = 0; j<=8; j++)
        {
            for(int i = 0; i<=8; i++){
                if(displayPuzzle[i][j].value == a)
                    countInstance++; //This will count the amount of instances of a in columns
            }
            while(countInstance > 1){
                int randomNumber = (rand() % 9); 
                if(displayPuzzle[randomNumber][j].value == a){
                    //kill
                    displayPuzzle[randomNumber][j].value = 0;
                    countInstance--;
                    //decrement
                }
            }
            countInstance = 0;
        }
    } 
} 

void getRowCandidates (board_box **displayPuzzle){
    //printf("\nRow Candidates:\n\n");
    for(int i = 0;i<=8;i++){
        for(int j = 0;j<=8;j++)
        {
            if(displayPuzzle[i][j].value == 0){ //if spot is blank we need to find candidate
                for (int p=1;p<=9;p++) //Go through every element in the row
                {
                    for(int x=0;x<=8;x++){ //match it to every element in candidate array
                        if(displayPuzzle[i][x].value == p) //This is true then we want to remove the value from candidates list
                        {
                            //removal of p from i j
                            displayPuzzle[i][j].candidates[p-1] = 0;
                            break;
                        }
                    }
                }  
            }
        }
    }
} 

void getColCandidates (board_box **displayPuzzle){
    //printf("\nColumn Candidates:\n\n");
    for(int i = 0;i<=8;i++){
        for(int j = 0;j<=8;j++)
        {
            if(displayPuzzle[i][j].value == 0){
                for (int p=1;p<=9;p++) //Go through every element in the row
                {
                    for(int x=0;x<=8;x++){ //match it to every element in candidate array
                        if(displayPuzzle[x][j].value == p) //if they match we set a trigger variable to 1
                        {
                            displayPuzzle[i][j].candidates[p-1] = 0;
                            break;
                        }
                    }
                }  
            }
        }
    }
} 
void getBoxCandidates(board_box **displayPuzzle)
{
    int iMin,jMin;
    //printf("\nBox Candidates:\n\n");
    for(int box = 0; box <= 8; box++) //We enter for loop that runs 9 times. Once for each box
    {
        switch(box){
        case 0 : //First iteration will select first box, second next and so on
            iMin = 0;
            jMin = 0;
            break;
        case 1 :
            iMin = 0;
            jMin = 3;
            break;
        case 2 :
            iMin = 0;
            jMin = 6;
            break;
        case 3 :
            iMin = 3;
            jMin = 0;
            break;
        case 4 :
            iMin = 3;
            jMin = 3;
            break;
        case 5 :
            iMin = 3;
            jMin = 6;
            break;
        case 6:
            iMin = 6;
            jMin = 0;
            break;
        case 7 :    
            iMin = 6;
            jMin = 3;
            break;
        case 8 :
            iMin = 6;
            jMin = 6;
            break;
        } //Once getting the index of the box we go into the box and put all the values in an array
        for(int row = iMin;row<=(iMin+2);row++){
            for(int col = jMin;col<=(jMin+2);col++)
            {
                if(displayPuzzle[row][col].value == 0){
                    for (int p=1;p<=9;p++) //Go through every element in the row
                    {
                        for(int i=iMin;i<=iMin+2;i++){ //match it to every element in candidate array
                            for(int j = jMin;j<=jMin+2;j++){
                                if(displayPuzzle[i][j].value == p) //if they match we set a trigger variable to 1
                                {
                                    displayPuzzle[row][col].candidates[p-1] = 0;
                                    break;
                                }
                            }
                        }
                    }  
                }
            }
        }
    }
}
void getCandidates (board_box **displayPuzzle){
    getRowCandidates(displayPuzzle); //wrapper function to find all candidates with one function
    getColCandidates(displayPuzzle);
    getBoxCandidates(displayPuzzle);
}

_Bool isValidBoard (board_box **displayPuzzle)
{
    // Test is to check if any empty spots candidates are 0
    for (int i=0;i<=8;i++)
    {
        for(int j=0;j<=8;j++)
        {
            if(displayPuzzle[i][j].value == 0)
            {
                if((displayPuzzle[i][j].candidates[0] || 
                displayPuzzle[i][j].candidates[1] || 
                displayPuzzle[i][j].candidates[2] || 
                displayPuzzle[i][j].candidates[3] || 
                displayPuzzle[i][j].candidates[4] || 
                displayPuzzle[i][j].candidates[5] || 
                displayPuzzle[i][j].candidates[6] || 
                displayPuzzle[i][j].candidates[7] || 
                displayPuzzle[i][j].candidates[8]) == 0)
                {
                    return false;
                }
            }
        }
    }
    return true;
}
void killRandomly(board_box **displayPuzzle){
    int randomNumber1;
    int randomNumber2;
    do{
        randomNumber1 = (rand() % 9); 
        randomNumber2 = (rand() % 9);
    }while(displayPuzzle[randomNumber1][randomNumber2].value == 0);
    displayPuzzle[randomNumber1][randomNumber2].value = 0; //kick entirely random coordinate in puzzle to be 0
}

board_box **create_fake_puzzle(){ //This function generates a puzzle full of zeroes
    board_box **fakePuzzle = allocateArray(9,9);
    for(int i=0;i<=8;i++){
        for(int j =0;j<=8;j++){
            fakePuzzle[i][j].value = 0;
        }
    }
    return fakePuzzle;
}
_Bool recursive_prune(board_box **displaypuzzle)
{
    fillCandidates(displaypuzzle);
    getCandidates(displaypuzzle);
    int i,j;
    static int recursion_count = 0;
    _Bool found = false;
    recursion_count ++;
    for (i=0;i<=8;i++) //We loop through puzzle until we find a spot that is 0
    {
        for(j=0;j<=8;j++)
        {
            if(displaypuzzle[i][j].value == 0){
                found = true;
                break;
            }
        }
        if(found)
            break;
    }
    if(i == 9 && j == 9) //If we are ever at this point that means we reached end of the puzzle and are done
    {
        recursion_count --;
        solutions_counter ++;
        return true; 
    }
    for(int k=1;k<=9;k++){
        fillCandidates(displaypuzzle);
        getCandidates(displaypuzzle);
        if(displaypuzzle[i][j].candidates[k-1]) //This runs true for first candidate in the empty spot
        {
            displaypuzzle[i][j].value = k; //This value needs to be one on the candidates list 
            if(isValidBoard(displaypuzzle)) //See if with this candidate in the empty spot, is puzzle still valid
            {
                //If recursive prune returns true, return true
                if(recursive_prune(displaypuzzle)) //recursively call functon
                {
                    recursion_count --;
                    return true;
                }
                fillCandidates(displaypuzzle);
                getCandidates(displaypuzzle);
            }
            displaypuzzle[i][j].value = 0; //Otherwise reset value to 0 and go to next candidate
        }
    }
    recursion_count --;
    return false;
}